{"version":3,"file":"component---src-pages-postlevels-js-fa9a9c869c9afd8a918d.js","mappings":"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","sources":["webpack://gatsby-starter-hello-world/./node_modules/@fluentui/react/lib/components/TextField/MaskedTextField/inputMask.js","webpack://gatsby-starter-hello-world/./node_modules/@fluentui/react/lib/components/TextField/MaskedTextField/MaskedTextField.js","webpack://gatsby-starter-hello-world/./src/pages/postlevels.js"],"sourcesContent":["export var DEFAULT_MASK_FORMAT_CHARS = {\n  '9': /[0-9]/,\n  a: /[a-zA-Z]/,\n  '*': /[a-zA-Z0-9]/\n};\n/**\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\n * Example:\n * mask = 'Phone Number: (999) - 9999'\n * return = [\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\n * ]\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param formatChars An object defining how certain characters in the mask should accept input.\n */\n\nexport function parseMask(mask, formatChars) {\n  if (formatChars === void 0) {\n    formatChars = DEFAULT_MASK_FORMAT_CHARS;\n  }\n\n  if (!mask) {\n    return [];\n  }\n\n  var maskCharData = []; // Count the escape characters in the mask string.\n\n  var escapedChars = 0;\n\n  for (var i = 0; i + escapedChars < mask.length; i++) {\n    var maskChar = mask.charAt(i + escapedChars);\n\n    if (maskChar === '\\\\') {\n      escapedChars++;\n    } else {\n      // Check if the maskChar is a format character.\n      var maskFormat = formatChars[maskChar];\n\n      if (maskFormat) {\n        maskCharData.push({\n          /**\n           * Do not add escapedChars to the displayIndex.\n           * The index refers to a position in the mask's displayValue.\n           * Since the backslashes don't appear in the displayValue,\n           * we do not add them to the charData displayIndex.\n           */\n          displayIndex: i,\n          format: maskFormat\n        });\n      }\n    }\n  }\n\n  return maskCharData;\n}\n/**\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\n * returns the mask string formatted with the input values and maskCharacter.\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * maskCharData = '12345'\n * maskChar = '_'\n * return = 'Phone Number: (123) 45_ - ___'\n *\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * value = '12345'\n * maskChar = undefined\n * return = 'Phone Number: (123) 45'\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param maskCharData The input values to insert into the mask string for displaying.\n * @param maskChar? A character to display in place of unfilled mask format characters.\n */\n\nexport function getMaskDisplay(mask, maskCharData, maskChar) {\n  var maskDisplay = mask;\n\n  if (!maskDisplay) {\n    return '';\n  } // Remove all backslashes\n\n\n  maskDisplay = maskDisplay.replace(/\\\\/g, ''); // lastDisplayIndex is is used to truncate the string if necessary.\n\n  var lastDisplayIndex = 0;\n\n  if (maskCharData.length > 0) {\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\n  }\n  /**\n   * For each input value, replace the character in the maskDisplay with the value.\n   * If there is no value set for the format character, use the maskChar.\n   */\n\n\n  for (var _i = 0, maskCharData_1 = maskCharData; _i < maskCharData_1.length; _i++) {\n    var charData = maskCharData_1[_i];\n    var nextChar = ' ';\n\n    if (charData.value) {\n      nextChar = charData.value;\n\n      if (charData.displayIndex > lastDisplayIndex) {\n        lastDisplayIndex = charData.displayIndex;\n      }\n    } else {\n      if (maskChar) {\n        nextChar = maskChar;\n      }\n    } // Insert the character into the maskdisplay at its corresponding index\n\n\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\n  } // Cut off all mask characters after the last filled format value\n\n\n  if (!maskChar) {\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\n  }\n\n  return maskDisplay;\n}\n/**\n * Get the next format index right of or at a specified index.\n * If no index exists, returns the rightmost index.\n * @param maskCharData\n * @param index\n */\n\nexport function getRightFormatIndex(maskCharData, index) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n\n  return maskCharData[maskCharData.length - 1].displayIndex;\n}\n/**\n * Get the next format index left of a specified index.\n * If no index exists, returns the leftmost index.\n * @param maskCharData\n * @param index\n */\n\nexport function getLeftFormatIndex(maskCharData, index) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n\n  return maskCharData[0].displayIndex;\n}\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n */\n\nexport function clearRange(maskCharData, selectionStart, selectionCount) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\n        break;\n      }\n\n      maskCharData[i].value = undefined;\n    }\n  }\n\n  return maskCharData;\n}\n/**\n * Deletes the input character at or after a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\n\nexport function clearNext(maskCharData, selectionStart) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n\n  return maskCharData;\n}\n/**\n * Deletes the input character before a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\n\nexport function clearPrev(maskCharData, selectionStart) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n\n  return maskCharData;\n}\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\n * next format character after the inserted string.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n * @return The displayIndex of the next format character\n */\n\nexport function insertString(maskCharData, selectionStart, newString) {\n  var stringIndex = 0;\n  var nextIndex = 0;\n  var isStringInserted = false; // Iterate through _maskCharData finding values with a displayIndex after the specified range start\n\n  for (var i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      isStringInserted = true;\n      nextIndex = maskCharData[i].displayIndex; // Find the next character in the newString that matches the format\n\n      while (stringIndex < newString.length) {\n        // If the character matches the format regexp, set the maskCharData to the new character\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\n          maskCharData[i].value = newString.charAt(stringIndex++); // Set the nextIndex to the display index of the next mask format character.\n\n          if (i + 1 < maskCharData.length) {\n            nextIndex = maskCharData[i + 1].displayIndex;\n          } else {\n            nextIndex++;\n          }\n\n          break;\n        }\n\n        stringIndex++;\n      }\n    }\n  }\n\n  return isStringInserted ? nextIndex : selectionStart;\n}","import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { TextField } from '../TextField';\nimport { KeyCodes } from '../../../Utilities';\nimport { clearNext, clearPrev, clearRange, DEFAULT_MASK_FORMAT_CHARS, getLeftFormatIndex, getMaskDisplay, getRightFormatIndex, insertString, parseMask } from './inputMask';\nimport { useConst } from '@fluentui/react-hooks';\nvar COMPONENT_NAME = 'MaskedTextField';\n\nvar useComponentRef = function useComponentRef(componentRef, internalState, textField) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get value() {\n        var value = '';\n\n        for (var i = 0; i < internalState.maskCharData.length; i++) {\n          if (!internalState.maskCharData[i].value) {\n            return undefined;\n          }\n\n          value += internalState.maskCharData[i].value;\n        }\n\n        return value;\n      },\n\n      get selectionStart() {\n        return textField.current && textField.current.selectionStart !== null ? textField.current.selectionStart : -1;\n      },\n\n      get selectionEnd() {\n        return textField.current && textField.current.selectionEnd ? textField.current.selectionEnd : -1;\n      },\n\n      focus: function focus() {\n        textField.current && textField.current.focus();\n      },\n      blur: function blur() {\n        textField.current && textField.current.blur();\n      },\n      select: function select() {\n        textField.current && textField.current.select();\n      },\n      setSelectionStart: function setSelectionStart(value) {\n        textField.current && textField.current.setSelectionStart(value);\n      },\n      setSelectionEnd: function setSelectionEnd(value) {\n        textField.current && textField.current.setSelectionEnd(value);\n      },\n      setSelectionRange: function setSelectionRange(start, end) {\n        textField.current && textField.current.setSelectionRange(start, end);\n      }\n    };\n  }, [internalState, textField]);\n};\n\nexport var DEFAULT_MASK_CHAR = '_';\nexport var MaskedTextField = React.forwardRef(function (props, ref) {\n  var textField = React.useRef(null);\n  var componentRef = props.componentRef,\n      onFocus = props.onFocus,\n      onBlur = props.onBlur,\n      onMouseDown = props.onMouseDown,\n      onMouseUp = props.onMouseUp,\n      onChange = props.onChange,\n      onPaste = props.onPaste,\n      onKeyDown = props.onKeyDown,\n      mask = props.mask,\n      _a = props.maskChar,\n      maskChar = _a === void 0 ? DEFAULT_MASK_CHAR : _a,\n      _b = props.maskFormat,\n      maskFormat = _b === void 0 ? DEFAULT_MASK_FORMAT_CHARS : _b,\n      value = props.value;\n  var internalState = useConst(function () {\n    return {\n      maskCharData: parseMask(mask, maskFormat),\n      isFocused: false,\n      moveCursorOnMouseUp: false,\n      changeSelectionData: null\n    };\n  });\n  /** The index into the rendered value of the first unfilled format character */\n\n  var _c = React.useState(),\n      maskCursorPosition = _c[0],\n      setMaskCursorPosition = _c[1];\n  /**\n   * The mask string formatted with the input value.\n   * This is what is displayed inside the TextField\n   * @example\n   *  `Phone Number: 12_ - 4___`\n   */\n\n\n  var _d = React.useState(function () {\n    return getMaskDisplay(mask, internalState.maskCharData, maskChar);\n  }),\n      displayValue = _d[0],\n      setDisplayValue = _d[1];\n\n  var setValue = React.useCallback(function (newValue) {\n    var valueIndex = 0;\n    var charDataIndex = 0;\n\n    while (valueIndex < newValue.length && charDataIndex < internalState.maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      var testVal = newValue[valueIndex];\n\n      if (internalState.maskCharData[charDataIndex].format.test(testVal)) {\n        internalState.maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n\n      valueIndex++;\n    }\n  }, [internalState]);\n  var handleFocus = React.useCallback(function (ev) {\n    onFocus === null || onFocus === void 0 ? void 0 : onFocus(ev);\n    internalState.isFocused = true; // Move the cursor position to the leftmost unfilled position\n\n    for (var i = 0; i < internalState.maskCharData.length; i++) {\n      if (!internalState.maskCharData[i].value) {\n        setMaskCursorPosition(internalState.maskCharData[i].displayIndex);\n        break;\n      }\n    }\n  }, [internalState, onFocus]);\n  var handleBlur = React.useCallback(function (ev) {\n    onBlur === null || onBlur === void 0 ? void 0 : onBlur(ev);\n    internalState.isFocused = false;\n    internalState.moveCursorOnMouseUp = true;\n  }, [internalState, onBlur]);\n  var handleMouseDown = React.useCallback(function (ev) {\n    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(ev);\n\n    if (!internalState.isFocused) {\n      internalState.moveCursorOnMouseUp = true;\n    }\n  }, [internalState, onMouseDown]);\n  var handleMouseUp = React.useCallback(function (ev) {\n    onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(ev); // Move the cursor on mouseUp after focusing the textField\n\n    if (internalState.moveCursorOnMouseUp) {\n      internalState.moveCursorOnMouseUp = false; // Move the cursor position to the rightmost unfilled position\n\n      for (var i = 0; i < internalState.maskCharData.length; i++) {\n        if (!internalState.maskCharData[i].value) {\n          setMaskCursorPosition(internalState.maskCharData[i].displayIndex);\n          break;\n        }\n      }\n    }\n  }, [internalState, onMouseUp]);\n  var handleInputChange = React.useCallback(function (ev, inputValue) {\n    if (internalState.changeSelectionData === null && textField.current) {\n      internalState.changeSelectionData = {\n        changeType: 'default',\n        selectionStart: textField.current.selectionStart !== null ? textField.current.selectionStart : -1,\n        selectionEnd: textField.current.selectionEnd !== null ? textField.current.selectionEnd : -1\n      };\n    }\n\n    if (!internalState.changeSelectionData) {\n      return;\n    } // The initial value of cursorPos does not matter\n\n\n    var cursorPos = 0;\n    var _a = internalState.changeSelectionData,\n        changeType = _a.changeType,\n        selectionStart = _a.selectionStart,\n        selectionEnd = _a.selectionEnd;\n\n    if (changeType === 'textPasted') {\n      var charsSelected = selectionEnd - selectionStart;\n      var charCount = inputValue.length + charsSelected - displayValue.length;\n      var startPos = selectionStart;\n      var pastedString = inputValue.substr(startPos, charCount); // Clear any selected characters\n\n      if (charsSelected) {\n        internalState.maskCharData = clearRange(internalState.maskCharData, selectionStart, charsSelected);\n      }\n\n      cursorPos = insertString(internalState.maskCharData, startPos, pastedString);\n    } else if (changeType === 'delete' || changeType === 'backspace') {\n      // isDel is true If the characters are removed LTR, otherwise RTL\n      var isDel = changeType === 'delete';\n      var charCount = selectionEnd - selectionStart;\n\n      if (charCount) {\n        // charCount is > 0 if range was deleted\n        internalState.maskCharData = clearRange(internalState.maskCharData, selectionStart, charCount);\n        cursorPos = getRightFormatIndex(internalState.maskCharData, selectionStart);\n      } else {\n        // If charCount === 0, there was no selection and a single character was deleted\n        if (isDel) {\n          internalState.maskCharData = clearNext(internalState.maskCharData, selectionStart);\n          cursorPos = getRightFormatIndex(internalState.maskCharData, selectionStart);\n        } else {\n          internalState.maskCharData = clearPrev(internalState.maskCharData, selectionStart);\n          cursorPos = getLeftFormatIndex(internalState.maskCharData, selectionStart);\n        }\n      }\n    } else if (inputValue.length > displayValue.length) {\n      // This case is if the user added characters\n      var charCount = inputValue.length - displayValue.length;\n      var startPos = selectionEnd - charCount;\n      var enteredString = inputValue.substr(startPos, charCount);\n      cursorPos = insertString(internalState.maskCharData, startPos, enteredString);\n    } else if (inputValue.length <= displayValue.length) {\n      /**\n       * This case is reached only if the user has selected a block of 1 or more\n       * characters and input a character replacing the characters they've selected.\n       */\n      var charCount = 1;\n      var selectCount = displayValue.length + charCount - inputValue.length;\n      var startPos = selectionEnd - charCount;\n      var enteredString = inputValue.substr(startPos, charCount); // Clear the selected range\n\n      internalState.maskCharData = clearRange(internalState.maskCharData, startPos, selectCount); // Insert the printed character\n\n      cursorPos = insertString(internalState.maskCharData, startPos, enteredString);\n    }\n\n    internalState.changeSelectionData = null;\n    var newValue = getMaskDisplay(mask, internalState.maskCharData, maskChar);\n    setDisplayValue(newValue);\n    setMaskCursorPosition(cursorPos); // Perform onChange after input has been processed. Return value is expected to be the displayed text\n\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, newValue);\n  }, [displayValue.length, internalState, mask, maskChar, onChange]);\n  var handleKeyDown = React.useCallback(function (ev) {\n    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);\n    internalState.changeSelectionData = null;\n\n    if (textField.current && textField.current.value) {\n      var keyCode = ev.keyCode,\n          ctrlKey = ev.ctrlKey,\n          metaKey = ev.metaKey; // Ignore ctrl and meta keydown\n\n      if (ctrlKey || metaKey) {\n        return;\n      } // On backspace or delete, store the selection and the keyCode\n\n\n      if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n        var selectionStart = ev.target.selectionStart;\n        var selectionEnd = ev.target.selectionEnd; // Check if backspace or delete press is valid.\n\n        if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) && !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < textField.current.value.length)) {\n          return;\n        }\n\n        internalState.changeSelectionData = {\n          changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n          selectionStart: selectionStart !== null ? selectionStart : -1,\n          selectionEnd: selectionEnd !== null ? selectionEnd : -1\n        };\n      }\n    }\n  }, [internalState, onKeyDown]);\n  var handlePaste = React.useCallback(function (ev) {\n    onPaste === null || onPaste === void 0 ? void 0 : onPaste(ev);\n    var selectionStart = ev.target.selectionStart;\n    var selectionEnd = ev.target.selectionEnd; // Store the paste selection range\n\n    internalState.changeSelectionData = {\n      changeType: 'textPasted',\n      selectionStart: selectionStart !== null ? selectionStart : -1,\n      selectionEnd: selectionEnd !== null ? selectionEnd : -1\n    };\n  }, [internalState, onPaste]); // Updates the display value if mask or value props change.\n\n  React.useEffect(function () {\n    internalState.maskCharData = parseMask(mask, maskFormat);\n    value !== undefined && setValue(value);\n    setDisplayValue(getMaskDisplay(mask, internalState.maskCharData, maskChar)); // eslint-disable-next-line react-hooks/exhaustive-deps -- Should only update when mask or value changes.\n  }, [mask, value]); // Run before browser paint to avoid flickering from selection reset.\n  // eslint-disable-next-line no-restricted-properties\n\n  React.useLayoutEffect(function () {\n    // Move the cursor to position before paint.\n    if (maskCursorPosition !== undefined && textField.current) {\n      textField.current.setSelectionRange(maskCursorPosition, maskCursorPosition);\n    }\n  }, [maskCursorPosition]); // Run after browser paint.\n\n  React.useEffect(function () {\n    // Move the cursor to the start of the mask format after values update.\n    if (internalState.isFocused && maskCursorPosition !== undefined && textField.current) {\n      textField.current.setSelectionRange(maskCursorPosition, maskCursorPosition);\n    }\n  });\n  useComponentRef(componentRef, internalState, textField);\n  return React.createElement(TextField, __assign({}, props, {\n    elementRef: ref,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onMouseDown: handleMouseDown,\n    onMouseUp: handleMouseUp,\n    onChange: handleInputChange,\n    onKeyDown: handleKeyDown,\n    onPaste: handlePaste,\n    value: displayValue || '',\n    componentRef: textField\n  }));\n});\nMaskedTextField.displayName = COMPONENT_NAME;","import React from \"react\"\r\nimport { Label } from \"@fluentui/react/lib/Label\"\r\nimport { TextField, MaskedTextField } from \"@fluentui/react/lib/TextField\"\r\nimport { mergeStyleSets } from \"@fluentui/react\"\r\nimport { Stack, IStackProps, IStackStyles } from \"@fluentui/react/lib/Stack\"\r\nimport { useId } from \"@fluentui/react-hooks\"\r\n\r\nexport default function PostLevels(props) {\r\n  const stackTokens = { childrenGap: 50 }\r\n  const iconProps = { iconName: \"Calendar\" }\r\n  const stackStyles = { root: { width: 650 } }\r\n  const columnProps = {\r\n    tokens: { childrenGap: 0 },\r\n    styles: { root: { width: 300 } },\r\n  }\r\n  const level1ID = useId(\"level1\")\r\n  const level1DateTimeID = useId(\"level1DateTime\")\r\n  const level2ID = useId(\"level2\")\r\n  const level2DateTimeID = useId(\"level2DateTime\")\r\n\r\n  return (\r\n    <div style={{ textAlign: \"left\" }}>\r\n      <h1>Post Levels</h1>\r\n      <p>This is the post levels page.</p>\r\n      <Stack horizontal tokens={stackTokens} styles={stackStyles}>\r\n        <Stack styles={{ root: { width: 120 } }}>\r\n          <Label style={{ textAlign: \"left\" }} required hmtlFor={level1ID}>\r\n            Level 1\r\n          </Label>\r\n          <TextField // prettier-ignore\r\n            id={level1ID}\r\n            style={{ textAlign: \"center\" }}\r\n            suffix=\"mg/dL\"\r\n            ariaLabel=\"Example text field with .com suffix\"\r\n          />\r\n          <Label style={{ textAlign: \"left\" }} required hmtlFor={level2ID}>\r\n            Level 2\r\n          </Label>\r\n          <TextField // prettier-ignore\r\n            id={level2ID}\r\n            style={{ textAlign: \"center\" }}\r\n            suffix=\"mg/dL\"\r\n            ariaLabel=\"Example text field with .com suffix\"\r\n          />\r\n        </Stack>\r\n\r\n        <Stack styles={{ root: { width: 120 } }}>\r\n          <Label\r\n            style={{ textAlign: \"left\", width: 140 }}\r\n            required\r\n            hmtlFor={level1DateTimeID}\r\n          >\r\n            Level 1 DateTime\r\n          </Label>\r\n          <MaskedTextField\r\n            id={level1DateTimeID}\r\n            style={{ textAlign: \"center\" }}\r\n            mask=\"99/99 99:99\"\r\n            title=\"DateTime\"\r\n          />\r\n          <Label\r\n            style={{ textAlign: \"left\", width: 140 }}\r\n            required\r\n            hmtlFor={level2DateTimeID}\r\n          >\r\n            Level 2 DateTime\r\n          </Label>\r\n          <MaskedTextField\r\n            id={level2DateTimeID}\r\n            style={{ textAlign: \"center\" }}\r\n            mask=\"99/99 99:99\"\r\n            title=\"DateTime\"\r\n          />\r\n        </Stack>\r\n      </Stack>\r\n    </div>\r\n  )\r\n}\r\n"],"names":["DEFAULT_MASK_FORMAT_CHARS","a","parseMask","mask","formatChars","maskCharData","escapedChars","i","length","maskChar","charAt","maskFormat","push","displayIndex","format","getMaskDisplay","maskDisplay","replace","lastDisplayIndex","_i","maskCharData_1","charData","nextChar","value","slice","getRightFormatIndex","index","clearRange","selectionStart","selectionCount","undefined","insertString","newString","stringIndex","nextIndex","isStringInserted","test","MaskedTextField","props","ref","textField","componentRef","onFocus","onBlur","onMouseDown","onMouseUp","onChange","onPaste","onKeyDown","_a","_b","internalState","useConst","isFocused","moveCursorOnMouseUp","changeSelectionData","_c","maskCursorPosition","setMaskCursorPosition","_d","displayValue","setDisplayValue","setValue","newValue","valueIndex","charDataIndex","testVal","handleFocus","ev","handleBlur","handleMouseDown","handleMouseUp","handleInputChange","inputValue","current","changeType","selectionEnd","cursorPos","charsSelected","charCount","startPos","pastedString","substr","isDel","clearNext","clearPrev","getLeftFormatIndex","enteredString","selectCount","handleKeyDown","keyCode","ctrlKey","metaKey","KeyCodes","target","handlePaste","setSelectionRange","focus","blur","select","setSelectionStart","setSelectionEnd","start","end","useComponentRef","TextField","elementRef","displayName","PostLevels","level1ID","useId","level1DateTimeID","level2ID","level2DateTimeID","style","textAlign","Stack","horizontal","tokens","childrenGap","styles","root","width","Label","required","hmtlFor","id","suffix","ariaLabel","title"],"sourceRoot":""}